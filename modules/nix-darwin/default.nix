{ lib, ... }:

let
  # This method of converting an attribute set to a Nix configuration file borrows heavily from the nix-darwin project:
  # https://github.com/nix-darwin/nix-darwin/blob/0d71cbf88d63e938b37b85b3bf8b238bcf7b39b9/modules/nix/default.nix#L34
  mkValueString = v:
    if v == null then ""
    else if builtins.isInt v then builtins.toString v
    else if builtins.isBool v then builtins.boolToString v
    else if builtins.isFloat v then lib.strings.floatToString v
    else if builtins.isList v then builtins.toString v
    else if lib.isDerivation v then builtins.toString v
    else if builtins.isPath v then builtins.toString v
    else if builtins.isString v then v
    else if builtins.isCoercibleToString v then builtins.toString v
    else abort "The nix conf value ${lib.toPretty {} v} can't be encoded";
  mkKeyValue = k: v: "${lib.escape [ "=" ] k} = ${mkValueString v}";
in
{
  options.determinate-nix.custom = lib.mkOption {
    # This method of typing Nix configuration borrows heavily from the nix-darwin project:
    # https://github.com/nix-darwin/nix-darwin/blob/0d71cbf88d63e938b37b85b3bf8b238bcf7b39b9/modules/nix/default.nix#L103
    type =
      let
        confAtom = lib.types.nullOr (lib.types.oneOf (with lib.types; [
          bool
          int
          float
          str
          path
          package
        ]));
      in
      lib.types.attrsOf (lib.types.either confAtom (lib.listOf confAtom));
    default = { };
  };

  config = lib.mkIf (config.determinate-nix.custom != { }) {
    environment.etc."nix/nix.custom.conf".text =
      lib.concatStringsSep "\n" (
        [
          "# This file is generated by the determinate module for nix-darwin."
          "# Update this file by changing your nix-darwin configuration, not by modifying it directly."
          ""
        ]
        ++ lib.mapAttrsToList mkKeyValue config.determinate-nix.custom
      );
  };
}
