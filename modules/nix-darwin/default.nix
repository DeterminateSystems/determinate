{ config, lib, ... }:

let
  inherit (lib) types;

  inherit (import ./config/config.nix { inherit lib; }) mkCustomConfig;

  semanticConfType =
    with types;
    let
      confAtom =
        nullOr (oneOf [
          bool
          int
          float
          str
          path
          package
        ])
        // {
          description = "Nix configuration atom (null, Boolean, integer, float, list, derivation, path, attribute set)";
        };
    in
    attrsOf (either confAtom (listOf confAtom));

  # Settings that Determinate Nix handles for you
  disallowedOptions = [
    "always-allow-substitutes"
    "bash-prompt-prefix"
    "netrc-file"
    "ssl-cert-file"
    "upgrade-nix-store-path-url"
  ];
in
{
  options.determinate-nix.customSettings = lib.mkOption {
    type = types.submodule {
      options = { };

      # Support "free-form" options
      freeformType = semanticConfType;
    };
    default = {};
  };

  config = lib.mkIf (config.determinate-nix.customSettings != { }) {
    assertions = [
      {
        assertion = lib.all (key: !lib.hasAttr key config.determinate-nix.customSettings) disallowedOptions;
        message = ''
          These settings are not allowed in `determinate-nix.customSettings`:
            ${lib.concatStringsSep ", " disallowedOptions}
        '';
      }
    ];

    environment.etc."nix/nix.custom.conf".text = lib.concatStringsSep "\n" (
      [
        "# This custom configuration file for Determinate Nix is generated by the determinate module for nix-darwin."
        "# Update your custom settings by changing your nix-darwin configuration, not by modifying this file directly."
        ""
      ]
      ++ mkCustomConfig config.determinate-nix.customSettings
    );
  };
}
